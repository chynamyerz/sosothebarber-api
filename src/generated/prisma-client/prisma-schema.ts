// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/
  export const typeDefs = /* GraphQL */ `type AggregateBooking {
    count: Int!
  }
  type AggregateCut {
    count: Int!
  }
  type AggregateUser {
    count: Int!
  }
  type BatchPayload {
    count: Long!
  }
  type Booking {
    id: ID!
    cut: Cut!
    user: User!
    date: DateTime!
    time: DateTime!
    status: BookingStatus!
    updatedAt: DateTime
    createdAt: DateTime
  }
  type BookingConnection {
    pageInfo: PageInfo!
    edges: [BookingEdge]!
    aggregate: AggregateBooking!
  }
  input BookingCreateInput {
    id: ID
    cut: CutCreateOneInput!
    user: UserCreateOneWithoutBookingsInput!
    date: DateTime!
    time: DateTime!
    status: BookingStatus!
  }
  input BookingCreateManyWithoutUserInput {
    create: [BookingCreateWithoutUserInput!]
    connect: [BookingWhereUniqueInput!]
  }
  input BookingCreateWithoutUserInput {
    id: ID
    cut: CutCreateOneInput!
    date: DateTime!
    time: DateTime!
    status: BookingStatus!
  }
  type BookingEdge {
    node: Booking!
    cursor: String!
  }
  enum BookingOrderByInput {
    id_ASC
    id_DESC
    date_ASC
    date_DESC
    time_ASC
    time_DESC
    status_ASC
    status_DESC
    updatedAt_ASC
    updatedAt_DESC
    createdAt_ASC
    createdAt_DESC
  }
  type BookingPreviousValues {
    id: ID!
    date: DateTime!
    time: DateTime!
    status: BookingStatus!
    updatedAt: DateTime
    createdAt: DateTime
  }
  input BookingScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    date: DateTime
    date_not: DateTime
    date_in: [DateTime!]
    date_not_in: [DateTime!]
    date_lt: DateTime
    date_lte: DateTime
    date_gt: DateTime
    date_gte: DateTime
    time: DateTime
    time_not: DateTime
    time_in: [DateTime!]
    time_not_in: [DateTime!]
    time_lt: DateTime
    time_lte: DateTime
    time_gt: DateTime
    time_gte: DateTime
    status: BookingStatus
    status_not: BookingStatus
    status_in: [BookingStatus!]
    status_not_in: [BookingStatus!]
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    AND: [BookingScalarWhereInput!]
    OR: [BookingScalarWhereInput!]
    NOT: [BookingScalarWhereInput!]
  }
  enum BookingStatus {
    ACTIVE
    DONE
    CANCELLED
    PENDING
  }
  type BookingSubscriptionPayload {
    mutation: MutationType!
    node: Booking
    updatedFields: [String!]
    previousValues: BookingPreviousValues
  }
  input BookingSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: BookingWhereInput
    AND: [BookingSubscriptionWhereInput!]
    OR: [BookingSubscriptionWhereInput!]
    NOT: [BookingSubscriptionWhereInput!]
  }
  input BookingUpdateInput {
    cut: CutUpdateOneRequiredInput
    user: UserUpdateOneRequiredWithoutBookingsInput
    date: DateTime
    time: DateTime
    status: BookingStatus
  }
  input BookingUpdateManyDataInput {
    date: DateTime
    time: DateTime
    status: BookingStatus
  }
  input BookingUpdateManyMutationInput {
    date: DateTime
    time: DateTime
    status: BookingStatus
  }
  input BookingUpdateManyWithoutUserInput {
    create: [BookingCreateWithoutUserInput!]
    delete: [BookingWhereUniqueInput!]
    connect: [BookingWhereUniqueInput!]
    set: [BookingWhereUniqueInput!]
    disconnect: [BookingWhereUniqueInput!]
    update: [BookingUpdateWithWhereUniqueWithoutUserInput!]
    upsert: [BookingUpsertWithWhereUniqueWithoutUserInput!]
    deleteMany: [BookingScalarWhereInput!]
    updateMany: [BookingUpdateManyWithWhereNestedInput!]
  }
  input BookingUpdateManyWithWhereNestedInput {
    where: BookingScalarWhereInput!
    data: BookingUpdateManyDataInput!
  }
  input BookingUpdateWithoutUserDataInput {
    cut: CutUpdateOneRequiredInput
    date: DateTime
    time: DateTime
    status: BookingStatus
  }
  input BookingUpdateWithWhereUniqueWithoutUserInput {
    where: BookingWhereUniqueInput!
    data: BookingUpdateWithoutUserDataInput!
  }
  input BookingUpsertWithWhereUniqueWithoutUserInput {
    where: BookingWhereUniqueInput!
    update: BookingUpdateWithoutUserDataInput!
    create: BookingCreateWithoutUserInput!
  }
  input BookingWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    cut: CutWhereInput
    user: UserWhereInput
    date: DateTime
    date_not: DateTime
    date_in: [DateTime!]
    date_not_in: [DateTime!]
    date_lt: DateTime
    date_lte: DateTime
    date_gt: DateTime
    date_gte: DateTime
    time: DateTime
    time_not: DateTime
    time_in: [DateTime!]
    time_not_in: [DateTime!]
    time_lt: DateTime
    time_lte: DateTime
    time_gt: DateTime
    time_gte: DateTime
    status: BookingStatus
    status_not: BookingStatus
    status_in: [BookingStatus!]
    status_not_in: [BookingStatus!]
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    AND: [BookingWhereInput!]
    OR: [BookingWhereInput!]
    NOT: [BookingWhereInput!]
  }
  input BookingWhereUniqueInput {
    id: ID
  }
  type Cut {
    id: ID!
    title: String!
    description: String!
    image: String!
    price: Int!
    updatedAt: DateTime
    createdAt: DateTime
  }
  type CutConnection {
    pageInfo: PageInfo!
    edges: [CutEdge]!
    aggregate: AggregateCut!
  }
  input CutCreateInput {
    id: ID
    title: String!
    description: String!
    image: String!
    price: Int!
  }
  input CutCreateOneInput {
    create: CutCreateInput
    connect: CutWhereUniqueInput
  }
  type CutEdge {
    node: Cut!
    cursor: String!
  }
  enum CutOrderByInput {
    id_ASC
    id_DESC
    title_ASC
    title_DESC
    description_ASC
    description_DESC
    image_ASC
    image_DESC
    price_ASC
    price_DESC
    updatedAt_ASC
    updatedAt_DESC
    createdAt_ASC
    createdAt_DESC
  }
  type CutPreviousValues {
    id: ID!
    title: String!
    description: String!
    image: String!
    price: Int!
    updatedAt: DateTime
    createdAt: DateTime
  }
  type CutSubscriptionPayload {
    mutation: MutationType!
    node: Cut
    updatedFields: [String!]
    previousValues: CutPreviousValues
  }
  input CutSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: CutWhereInput
    AND: [CutSubscriptionWhereInput!]
    OR: [CutSubscriptionWhereInput!]
    NOT: [CutSubscriptionWhereInput!]
  }
  input CutUpdateDataInput {
    title: String
    description: String
    image: String
    price: Int
  }
  input CutUpdateInput {
    title: String
    description: String
    image: String
    price: Int
  }
  input CutUpdateManyMutationInput {
    title: String
    description: String
    image: String
    price: Int
  }
  input CutUpdateOneRequiredInput {
    create: CutCreateInput
    update: CutUpdateDataInput
    upsert: CutUpsertNestedInput
    connect: CutWhereUniqueInput
  }
  input CutUpsertNestedInput {
    update: CutUpdateDataInput!
    create: CutCreateInput!
  }
  input CutWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    title: String
    title_not: String
    title_in: [String!]
    title_not_in: [String!]
    title_lt: String
    title_lte: String
    title_gt: String
    title_gte: String
    title_contains: String
    title_not_contains: String
    title_starts_with: String
    title_not_starts_with: String
    title_ends_with: String
    title_not_ends_with: String
    description: String
    description_not: String
    description_in: [String!]
    description_not_in: [String!]
    description_lt: String
    description_lte: String
    description_gt: String
    description_gte: String
    description_contains: String
    description_not_contains: String
    description_starts_with: String
    description_not_starts_with: String
    description_ends_with: String
    description_not_ends_with: String
    image: String
    image_not: String
    image_in: [String!]
    image_not_in: [String!]
    image_lt: String
    image_lte: String
    image_gt: String
    image_gte: String
    image_contains: String
    image_not_contains: String
    image_starts_with: String
    image_not_starts_with: String
    image_ends_with: String
    image_not_ends_with: String
    price: Int
    price_not: Int
    price_in: [Int!]
    price_not_in: [Int!]
    price_lt: Int
    price_lte: Int
    price_gt: Int
    price_gte: Int
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    AND: [CutWhereInput!]
    OR: [CutWhereInput!]
    NOT: [CutWhereInput!]
  }
  input CutWhereUniqueInput {
    id: ID
  }
  scalar DateTime
  scalar Long
  type Mutation {
    createBooking(data: BookingCreateInput!): Booking!
    updateBooking(data: BookingUpdateInput!, where: BookingWhereUniqueInput!): Booking
    updateManyBookings(data: BookingUpdateManyMutationInput!, where: BookingWhereInput): BatchPayload!
    upsertBooking(where: BookingWhereUniqueInput!, create: BookingCreateInput!, update: BookingUpdateInput!): Booking!
    deleteBooking(where: BookingWhereUniqueInput!): Booking
    deleteManyBookings(where: BookingWhereInput): BatchPayload!
    createCut(data: CutCreateInput!): Cut!
    updateCut(data: CutUpdateInput!, where: CutWhereUniqueInput!): Cut
    updateManyCuts(data: CutUpdateManyMutationInput!, where: CutWhereInput): BatchPayload!
    upsertCut(where: CutWhereUniqueInput!, create: CutCreateInput!, update: CutUpdateInput!): Cut!
    deleteCut(where: CutWhereUniqueInput!): Cut
    deleteManyCuts(where: CutWhereInput): BatchPayload!
    createUser(data: UserCreateInput!): User!
    updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
    updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
    upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
    deleteUser(where: UserWhereUniqueInput!): User
    deleteManyUsers(where: UserWhereInput): BatchPayload!
  }
  enum MutationType {
    CREATED
    UPDATED
    DELETED
  }
  interface Node {
    id: ID!
  }
  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }
  type Query {
    booking(where: BookingWhereUniqueInput!): Booking
    bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking]!
    bookingsConnection(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookingConnection!
    cut(where: CutWhereUniqueInput!): Cut
    cuts(where: CutWhereInput, orderBy: CutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cut]!
    cutsConnection(where: CutWhereInput, orderBy: CutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CutConnection!
    user(where: UserWhereUniqueInput!): User
    users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
    usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
    node(id: ID!): Node
  }
  enum Role {
    ADMIN
  }
  type Subscription {
    booking(where: BookingSubscriptionWhereInput): BookingSubscriptionPayload
    cut(where: CutSubscriptionWhereInput): CutSubscriptionPayload
    user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  }
  type User {
    id: ID!
    email: String!
    displayName: String!
    phoneNumber: String!
    password: String!
    bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking!]
    oneTimePin: String
    role: Role
    resetTokenExpiry: DateTime
    updatedAt: DateTime
    createdAt: DateTime
  }
  type UserConnection {
    pageInfo: PageInfo!
    edges: [UserEdge]!
    aggregate: AggregateUser!
  }
  input UserCreateInput {
    id: ID
    email: String!
    displayName: String!
    phoneNumber: String!
    password: String!
    bookings: BookingCreateManyWithoutUserInput
    oneTimePin: String
    role: Role
    resetTokenExpiry: DateTime
  }
  input UserCreateOneWithoutBookingsInput {
    create: UserCreateWithoutBookingsInput
    connect: UserWhereUniqueInput
  }
  input UserCreateWithoutBookingsInput {
    id: ID
    email: String!
    displayName: String!
    phoneNumber: String!
    password: String!
    oneTimePin: String
    role: Role
    resetTokenExpiry: DateTime
  }
  type UserEdge {
    node: User!
    cursor: String!
  }
  enum UserOrderByInput {
    id_ASC
    id_DESC
    email_ASC
    email_DESC
    displayName_ASC
    displayName_DESC
    phoneNumber_ASC
    phoneNumber_DESC
    password_ASC
    password_DESC
    oneTimePin_ASC
    oneTimePin_DESC
    role_ASC
    role_DESC
    resetTokenExpiry_ASC
    resetTokenExpiry_DESC
    updatedAt_ASC
    updatedAt_DESC
    createdAt_ASC
    createdAt_DESC
  }
  type UserPreviousValues {
    id: ID!
    email: String!
    displayName: String!
    phoneNumber: String!
    password: String!
    oneTimePin: String
    role: Role
    resetTokenExpiry: DateTime
    updatedAt: DateTime
    createdAt: DateTime
  }
  type UserSubscriptionPayload {
    mutation: MutationType!
    node: User
    updatedFields: [String!]
    previousValues: UserPreviousValues
  }
  input UserSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: UserWhereInput
    AND: [UserSubscriptionWhereInput!]
    OR: [UserSubscriptionWhereInput!]
    NOT: [UserSubscriptionWhereInput!]
  }
  input UserUpdateInput {
    email: String
    displayName: String
    phoneNumber: String
    password: String
    bookings: BookingUpdateManyWithoutUserInput
    oneTimePin: String
    role: Role
    resetTokenExpiry: DateTime
  }
  input UserUpdateManyMutationInput {
    email: String
    displayName: String
    phoneNumber: String
    password: String
    oneTimePin: String
    role: Role
    resetTokenExpiry: DateTime
  }
  input UserUpdateOneRequiredWithoutBookingsInput {
    create: UserCreateWithoutBookingsInput
    update: UserUpdateWithoutBookingsDataInput
    upsert: UserUpsertWithoutBookingsInput
    connect: UserWhereUniqueInput
  }
  input UserUpdateWithoutBookingsDataInput {
    email: String
    displayName: String
    phoneNumber: String
    password: String
    oneTimePin: String
    role: Role
    resetTokenExpiry: DateTime
  }
  input UserUpsertWithoutBookingsInput {
    update: UserUpdateWithoutBookingsDataInput!
    create: UserCreateWithoutBookingsInput!
  }
  input UserWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    email: String
    email_not: String
    email_in: [String!]
    email_not_in: [String!]
    email_lt: String
    email_lte: String
    email_gt: String
    email_gte: String
    email_contains: String
    email_not_contains: String
    email_starts_with: String
    email_not_starts_with: String
    email_ends_with: String
    email_not_ends_with: String
    displayName: String
    displayName_not: String
    displayName_in: [String!]
    displayName_not_in: [String!]
    displayName_lt: String
    displayName_lte: String
    displayName_gt: String
    displayName_gte: String
    displayName_contains: String
    displayName_not_contains: String
    displayName_starts_with: String
    displayName_not_starts_with: String
    displayName_ends_with: String
    displayName_not_ends_with: String
    phoneNumber: String
    phoneNumber_not: String
    phoneNumber_in: [String!]
    phoneNumber_not_in: [String!]
    phoneNumber_lt: String
    phoneNumber_lte: String
    phoneNumber_gt: String
    phoneNumber_gte: String
    phoneNumber_contains: String
    phoneNumber_not_contains: String
    phoneNumber_starts_with: String
    phoneNumber_not_starts_with: String
    phoneNumber_ends_with: String
    phoneNumber_not_ends_with: String
    password: String
    password_not: String
    password_in: [String!]
    password_not_in: [String!]
    password_lt: String
    password_lte: String
    password_gt: String
    password_gte: String
    password_contains: String
    password_not_contains: String
    password_starts_with: String
    password_not_starts_with: String
    password_ends_with: String
    password_not_ends_with: String
    bookings_every: BookingWhereInput
    bookings_some: BookingWhereInput
    bookings_none: BookingWhereInput
    oneTimePin: String
    oneTimePin_not: String
    oneTimePin_in: [String!]
    oneTimePin_not_in: [String!]
    oneTimePin_lt: String
    oneTimePin_lte: String
    oneTimePin_gt: String
    oneTimePin_gte: String
    oneTimePin_contains: String
    oneTimePin_not_contains: String
    oneTimePin_starts_with: String
    oneTimePin_not_starts_with: String
    oneTimePin_ends_with: String
    oneTimePin_not_ends_with: String
    role: Role
    role_not: Role
    role_in: [Role!]
    role_not_in: [Role!]
    resetTokenExpiry: DateTime
    resetTokenExpiry_not: DateTime
    resetTokenExpiry_in: [DateTime!]
    resetTokenExpiry_not_in: [DateTime!]
    resetTokenExpiry_lt: DateTime
    resetTokenExpiry_lte: DateTime
    resetTokenExpiry_gt: DateTime
    resetTokenExpiry_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    AND: [UserWhereInput!]
    OR: [UserWhereInput!]
    NOT: [UserWhereInput!]
  }
  input UserWhereUniqueInput {
    id: ID
    email: String
  }
  `
  